#pragma once

#include <boost/optional.hpp>

using namespace std;
namespace ts {
namespace namedobj {
	
template <typename T>
struct NamedObject {
  static map<string, T*> namedList_;
  static vector<T> trash_;
  mutable string name_;
  bool nameReference_ = false;
  mutable int32_t ref_ = 0;
  bool moved_ = false;
  NamedObject() {}
  NamedObject(string&& n, bool ref=false) : name_(move(n)) , nameReference_(ref) { regist(); }
  NamedObject(const string& n, bool ref=false) : name_(n) , nameReference_(ref) { regist(); }
  NamedObject(NamedObject&& n)
  : name_(move(n.name_))
  , nameReference_(n.nameReference_) {
	regist();
	n.name_ += name_ + "@moved";
	n.moved_ = true;
  }
  ~NamedObject() {
	if (!(nameReference_ || moved_)) {
	  cerr << "destruct: " << name_ << " has not moved" << endl;
	}
	//assert(nameReference_ || moved_);
  }

  void release() {
	if (!nameReference_ && !moved_) {
	  // moveされていなかったら実体をとっておく
	  cerr << "'" << name_ << "' go to trash box" << endl;
	  trash_.emplace_back(move(static_cast<T&&>(*this)));
	}
  }
  
  NamedObject& operator = (NamedObject&& n) {
	name_ = move(n.name_);
	nameReference_ = n.nameReference_;
	regist();
	n.name_ = name_ + "@moved";
	n.moved_ = true;
	return *this;
  }
  NamedObject& operator = (const NamedObject& n)  = delete; 

  boost::optional<T&> getBody() {
	if (nameReference_) return lookup(name_);
	return static_cast<T&>(*this);
  }
  boost::optional<const T&> getBody() const {
	if (nameReference_) {
	  if (auto f = lookup(name_)) {
		return f.get();
	  }
	  else {
		return boost::none;
	  }
	}
	return static_cast<const T&>(*this);
  }

  const string& name() const { return name_; }
  string& nameRef() { return name_; }

  static boost::optional<T&> lookup(const string& name) {
	/*
	cerr << "lookup" << endl;
	for (auto& n : namedList_) {
	  cerr << n.first << ":" << n.second << endl;
	}
	cerr << "/" << endl;
	*/
	auto found = namedList_.find(name);
	if (found != namedList_.end()) {
	  return *found->second;
	}
	else {
	  return boost::none;
	}
  }

  void setUniqName() const {
	if (name_.empty()) {
	  name_ = to_string(namedList_.size());
	  regist();
	  --ref_;
	}
  }

private:
  void regist() const {
	if (!nameReference_) {
	  // 実体だったら
	  if (!name_.empty()) {
		cerr << "regist:" << name_ << ": " << this << endl;
		namedList_[name_] = const_cast<T*>(static_cast<const T*>(this));
	  }
	}
	else {
	  // 参照だったら
	  assert(!name_.empty());
	}
  }
};

template <typename T>
map<string, T*> NamedObject<T>::namedList_;
template <typename T>
vector<T> NamedObject<T>::trash_;


}} // ts::namedobj
