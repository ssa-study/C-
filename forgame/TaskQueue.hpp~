#pragma once
namespace ts {
namespace namedobj {

using TaskHolder = Task::TaskHolder;
using TaskArgs = Task::TaskArgs;
  
class TaskQueue {
  deque<Task> queue_;
  deque<Task> nextqueue_;
  vector<Task> trash_;
public:
  
  void addTask(Task&& task) {
	cerr << "addTask1:" << task.name() << endl;
	task.valid("addtask");
	nextqueue_.emplace_back(move(task));
	cerr << "addTask1 done:" << task.name() << endl;
  }
  void addTask(const Task& task) {
	task.valid("addtask3");
	cerr << "addTask3:" << task.name() << endl;
	nextqueue_.emplace_back(move(task.makeReference()));
	nextqueue_.back().getBody()->valid("addtask33");
	cerr << "addTask3 done" << endl;
  }
  void update() {
	while (!queue_.empty()) {
	  TaskHolder task(std::move(queue_.front()));
	  queue_.pop_front();
	  cerr << "taskname: " << task.get().name_ << endl;
	  if (task.get().nameReference_) {
		cout << "task'" << task.get().name() << "' is reference" << endl;
		if (auto found = task.get().getBody()) {
		  cerr << "found check" << endl;
		  found->valid("update");
		  cerr << "found is ok :" << found->name() << endl;
		  task = TaskHolder(&found.get());
		  assert(task.get().func_);
		  task.get().valid("found and get");
		}
		else {
		  // error
		  cerr << "task:" << task.get().name() << " not found" << endl;
		  assert(0);
		  continue;
		}
	  }
	  else {
		task.get().valid("queue front");
	  }
	  assert(task.get().hasFunction());
	  cerr << "it task empty?" << endl;
	  assert(!task.get().empty());
	  cerr << "task.get().valid();" << endl;
	  task.get().valid("get");
	  cerr << "update do task()" << endl;
	  auto& taskbody = task.get();
	  assert(taskbody.func_);
	  auto ret = taskbody.go();
	  cerr << "update do task(" << taskbody.name() << ") done" << endl;
	  switch (ret) {
	  case TaskStatus::RemoveTask:
		if (task.hasBody() && !task.get().name().empty()) {
		  trash_.emplace_back(move(task.get()));
		}
		break;
	  case TaskStatus::ContinueTask:
		task.get().valid("continue");
		addTask(std::move(task.get()));
		break;
	  default:
		break;
	  }
	}
	swap(queue_, nextqueue_);
  }
  Task root_;
  void run(Task&& func) {
	root_ = move(func);
	cerr << "run: " << root_.name() << endl;
	addTask(move(root_));
	cerr << "run: task added " << func.name() << endl;
  }


  void waitPred(Task& next, function<bool()> pred) {
	cerr << "waitPred" << endl;
	string ref = next.makeReference().name_;
	Task t([this, ref, pred](TaskArgs&){
		Task nh(ref);
		cerr << "waitPred" << endl;
		if (pred()) {
		  cerr << "addTask" << endl;
		  nh.getBody()->valid("waitPred");
		  addTask(nh);
		  return TaskStatus::RemoveTask;
		}
		else {
		  return TaskStatus::ContinueTask;
		}
	  });
	t.valid("waitPred2");
	addTask(std::move(t));
  }
};


}} // ts::namedobj
  
